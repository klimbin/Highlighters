{"version":3,"sources":["components/Highlight.js","components/App.js","serviceWorker.js","index.js"],"names":["Highlight","startOffset","endOffset","color","priority","Object","classCallCheck","this","createClass","key","value","concat","get","_startOffset","set","_endOffset","_color","_priority","HighlightPanel","deleteHighlight","_this","props","highlightChange","renderHighlightBox","highlight","phrase","classNames","style","backgroundColor","react_default","a","createElement","className","substring","onClick","aria-hidden","_this2","highlightBoxes","highlights","map","id","Component","INITIAL_STATE","inputText","highlightRender","App","possibleConstructorReturn","getPrototypeOf","call","removeHighlight","newHighlights","state","filter","h","setState","updateRenders","_this$state","renders","calculateRenders","length","newRender","getHighlightedText","split","join","objectSpread","_this$state2","dangerouslySetInnerHTML","__html","src_components_Highlight","inputLength","sort","b","spotsFilled","repeat","i","current","_ref","start","end","_ref2","sectionToConsider","firstOccurrence","indexOf","push","lastOccurrence","lastIndexOf","nextOccurrence","string","sections","result","currentIndex","_sections$i","slicedToArray","section","Boolean","window","location","hostname","match","ReactDOM","render","components_App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.f66cd3a3.chunk.js","sourcesContent":["import React, { Component } from 'react';\nimport './Highlight.css';\n\n/** Class representing a highlight. */\nconst Highlight = class {\n  /**\n   * Create a Highlight object.\n   * @param {number} startOffset - The startOffset value.\n   * @param {number} endOffset - The endOffset value.\n   * @param {string} color - The highlight color.\n   * @param {number} priority - The priority of the highlight.\n   */\n  constructor(startOffset, endOffset, color, priority) {\n      this.startOffset = startOffset;\n      this.endOffset = endOffset;\n      this.color = color;\n      this.priority = priority;\n  }\n\n  /**\n   * @return {string} A string representing this Highlight object.\n   */\n  toString() {\n      return `Highlight: (${this.startOffset},${this.endOffset})` +\n              `, ${this.color}, priority = ${this.priority}`;\n  }\n\n  /**\n   * Get the startOffset value.\n   * @return {number} The startOffset value.\n   */\n  get startOffset() {\n      return this._startOffset;\n  }\n\n  /**\n   * Get the endOffset value.\n   * @return {number} The endOffset value.\n   */\n  get endOffset() {\n      return this._endOffset;\n  }\n\n  /**\n   * Get the color value.\n   * @return {string} The color value.\n   */\n  get color() {\n      return this._color;\n  }\n\n  /**\n   * Get the priority value.\n   * @return {number} The priority value.\n   */\n  get priority() {\n      return this._priority;\n  }\n\n  /**\n   * Set the startOffset value.\n   * @param {number} The startOffset value.\n   */\n  set startOffset(value) {\n      this._startOffset = value;\n  }\n\n  /**\n   * Set the endOffset value.\n   * @param {number} The endOffset value.\n   */\n  set endOffset(value) {\n      this._endOffset = value;\n  }\n\n  /**\n   * Set the color value.\n   * @param {string} The color value.\n   */\n  set color(value) {\n      this._color = value;\n  }\n\n  /**\n   * Set the priority value.\n   * @param {number} The priority value.\n   */\n  set priority(value) {\n      this._priority = value;\n  }\n};\n\n/** This class renders boxes to represent each highlight object. */\nclass HighlightPanel extends Component {\n  /**\n   * This method takes a key unique to a highlight object\n   * then calls a callback function to remove the given highlight.\n   * Note that we use the highlight priority for the key.\n   *\n   * @param {Number.} key\n   */\n  deleteHighlight = (key) => {\n    this.props.highlightChange(key);\n  }\n\n  /**\n   * This method takes a highlight object and\n   * returns a div representing the highlight.\n   *\n   * @param {Object.<Highlight>} highlight\n   */\n  renderHighlightBox = (highlight) => {\n    const phrase = this.props.phrase;\n    const {startOffset, endOffset, color, priority} = highlight;\n    const classNames = ['card render-' + priority]\n    const style = {backgroundColor: color};\n    return (\n      <div key={priority} className={classNames} style={style}>\n        <div className=\"card-body\">\n          <h5 className=\"card-title\">\n            Highlight {priority}\n          </h5>\n          <h6 className=\"card-subtitle\">\n            ({startOffset}, {endOffset})\n          </h6>\n          <div className=\"card-text\">\n            <p>\n              \"{phrase.substring(startOffset, endOffset)}\"\n            </p>\n            <button\n              className=\"btn btn-outline-dark\"\n              onClick={() => this.deleteHighlight(priority)}\n            >\n              <span aria-hidden=\"true\">remove</span>\n            </button>\n          </div>\n        </div>\n      </div>\n    )\n  }\n\n  render() {\n    const highlightBoxes = this.props.highlights.map(highlight =>\n      this.renderHighlightBox(highlight)\n    );\n\n    return (\n      <div id=\"highlightBoxContainer\">\n        { highlightBoxes }\n      </div>\n    );\n  }\n}\n\nexport default HighlightPanel;\nexport { Highlight };\n","import React, { Component } from 'react';\nimport HighlightPanel, { Highlight } from './Highlight';\n\n/** Defines the text of the page to search through.\n * @constant\n */\nconst pageText = `\n  This is a test.</br>\n  You will deliver new technology with an adorable puppy. Perfect!</br>\n  This is just a test.</br>\n  You will deliver new technology with an adorable puppy. Perfect!</br>\n  I love chocolate.</br>\n  You will deliver new technology with an adorable puppy. Perfect!</br>\n  You will deliver new technology with an adorable puppy. Perfect!</br>`;\n\nconst INITIAL_STATE = {\n  inputText: pageText,\n  phrase: 'You will deliver new technology with an adorable puppy. Perfect!',\n  highlights: [\n    new Highlight(29,30,'orange',0),\n    new Highlight(24,27,'#eccf98',1),\n    new Highlight(4, 18, '#d9f593', 2),\n    new Highlight(19, 22, '#e8e8e8', 3),\n    new Highlight(17, 31, '#c6e5fa', 4),\n    new Highlight(40, 48, '#d9f593', 5),\n    new Highlight(40, 55, '#ee93f5', 6),\n    new Highlight(37, 55, '#c6e5fa', 7),\n    new Highlight(56, 64, '#eccf98', 8),\n    new Highlight(-200, 200, 'yellow', 90)\n  ],\n  highlightRender: null\n};\n\n/** This class will render the highlights for the phrase\n *  on every occurrence in the pageText.\n */\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    this.state = { ...INITIAL_STATE};\n  }\n\n  componentDidMount() {\n    this.updateRenders();\n  }\n\n  /**\n   * This method takes a key unique to a highlight object\n   * then removes the given highlight from the App state.\n   * Note that we use the highlight priority for the key.\n   *\n   * @param {Number.} key\n   */\n  removeHighlight = (key) => {\n    const { highlights } = this.state;\n    const newHighlights = highlights.filter((h) => h.priority !== key);\n    this.setState({ highlights: newHighlights }, this.updateRenders);\n  }\n\n  /**\n   * This method clears the previous renders\n   * and creates new highlight renders.\n   *\n   * @param {Number.} key\n   */\n  updateRenders = () => {\n    const { inputText, phrase, highlights, highlightRender } = this.state;\n    const renders = calculateRenders(phrase.length, highlights);\n    const newRender = getHighlightedText(phrase, renders);\n    this.setState({ highlightRender: inputText.split(phrase).join(newRender) });\n  }\n\n  render() {\n    const { phrase, highlights, highlightRender } = this.state;\n    return(\n      <div>\n        <div dangerouslySetInnerHTML={{__html: highlightRender}}></div>\n        <HighlightPanel\n          phrase={phrase}\n          highlights={highlights}\n          highlightChange={this.removeHighlight}\n        />\n      </div>\n    )\n  }\n}\n\nexport default App;\n\n/**\n * This function takes an array of highlight objects and\n * and normalizes the ranges to create a set of highlight\n * renders without any overlapping.\n *\n * Highlight renders are arrays represented by [start, end, color, priority].\n *\n * @param {Number} inputLength - The length of the phrase to be highlighted.\n * @param {Array.<Highlight>} highlights - A set of highlight objects.\n *\n * @return {Array.<Array.<Number, Number, String, Number>>} An array of highlight renders.\n */\nconst calculateRenders = (inputLength, highlights) => {\n  // sort highlights from top to bottom by their priority\n  // note that lower numbers are higher in priority\n  highlights.sort((a,b) => a.priority - b.priority);\n\n  // renders will store set of highlight objects that do not overlap\n  let renders = [];\n\n  // this string will represent which indices are already highlighted\n  let spotsFilled = '0'.repeat(inputLength);\n\n  for (let i = 0; i < highlights.length; i++) {\n    let current = highlights[i];\n    let [start, end] = [current.startOffset, current.endOffset];\n\n    // ignore current highlight if it does not have a valid range\n    if(start >= end || end <= 0 || start >= inputLength) {\n      continue;\n    }\n    if(start < 0) {\n      start = 0;\n    }\n    if(end > inputLength) {\n      end = inputLength;\n    }\n\n    let [color, priority] = [current.color, current.priority];\n    let sectionToConsider = spotsFilled.substring(start, end);\n    let firstOccurrence = sectionToConsider.indexOf('1');\n\n    if(firstOccurrence === -1) {\n      // no overlaps with other highlights\n      renders.push([start, end, color, priority]);\n    }\n    else {\n      // there is overlapping with other highlight(s)\n      if(firstOccurrence > 0) {\n        renders.push([start, start+firstOccurrence, color, priority]);\n      }\n\n      let lastOccurrence = sectionToConsider.lastIndexOf('1');\n\n      // handle cases of multiple highlight overlaps\n      let nextOccurrence = sectionToConsider.indexOf('1', firstOccurrence+1);\n      while(nextOccurrence !== -1) {\n        if(nextOccurrence - firstOccurrence > 1) {\n          renders.push([start+firstOccurrence+1, start+nextOccurrence, color, priority]);\n        }\n        firstOccurrence = nextOccurrence;\n        nextOccurrence = sectionToConsider.indexOf('1', firstOccurrence+1);\n      }\n\n      if(lastOccurrence < sectionToConsider.length-1) {\n        renders.push([start+lastOccurrence+1, end, color, priority]);\n      }\n    }\n    spotsFilled = spotsFilled.substring(0, start) + '1'.repeat(end-start) + spotsFilled.substring(end);\n  }\n  return renders;\n}\n\n/**\n * This function takes a set of highlight renders\n * and returns HTML code to represent the highlights.\n * The highlight renders must not have overlaps.\n *\n * @param {string} string - The phrase to be highlighted.\n * @param {Array.<Array.<Number, Number, String, Number>>} sections\n *\n * Highlight renders are represented by [start, end, color, priority].\n *\n * @return {string} HTML markup representing the highlighted phrase.\n */\nconst getHighlightedText = (string, sections) => {\n  // sort sections by increasing startOffset\n  sections.sort((a,b) => a[0] - b[0]);\n\n  // append each section with their highlights\n  let result = [];\n  let currentIndex = 0;\n  for(let i = 0; i < sections.length; i++) {\n    let [start, end, color, priority] = sections[i];\n    let section = string.substring(currentIndex, start);\n    section += `<span class=\"render-${priority}\"` +\n               ` style=\"background-color:${color}\">` +\n               `${string.substring(start, end)}</span>`;\n    result.push(section);\n    currentIndex = end;\n  }\n  result.push(string.substring(currentIndex));\n  return result.join('');\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport 'bootstrap/dist/css/bootstrap.css';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}